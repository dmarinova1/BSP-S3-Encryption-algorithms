\section{BSPro - A First Bachelor Semester Project in BiCS-land}
\subsection{Requirements ($\pm$ 15\% total words)}

Ciphers have been used long before apparition of computers. During Roman times, Julius Caesar invented an encryption for his private correspondence. Today, it is known as the Caesar cipher. Given the English alphabet, the cipher shifts a letter from the alphabet three places to the right, i.e. A is encrypted as D, B as E,etc. It is a monoalphabetic cipher. To decrypt the message, the other party needs to know both the algorithm and the shifting number. The secret key shared by the sender and the recipient of the message is k=3. Breaking the Caesar Cipher can be done by testing all possible shifts. Since an alphabet of length 26 is used we have to test 26 shifts. 

ROT13 is a simple monoalphabetic substitution cipher, a special class of Caesar cipher, that encodes a certain letter with another letter that is 13 positions after it. Only those letters which occur in the English alphabet are affected. Numbers, symbols, whitespace, and all other characters are left unchanged. It is an example of a cipher providing weak encryption, since both operations encryption and decryption are identical. Hence, this cipher is its own inverse. Because we know there are 26 letters in the English alphabet, if we wish to apply twice 13 it would give us one shift of 26. Thus, it leads us back to the original text. Moreover, the direction of the shift is of no importance, since it will always give the same output \cite{swenson2008modern}.
ROT13 is used in online forums as a means of hiding spoilers, punchlines, puzzle solutions, and offensive materials from the casual glance. Furthermore, it has inspired a variety of letter and word games online \cite{wikirot13}. 

Another cipher our project deals with is the block cipher Data Encryption Standard (DES). In DES we put 64-bit block of plaintext,  DES' key (which does the processing) is 64 bit which is 8 bytes but for each byte there is one parity bit, therefore, the value in the key is only 56 bits which means there are 2 to the power of 56 different keys. The output ciphertext is a 64-bit block. 
From the 56-bit key, 16 bits are generated (one for each round). Each DES round works consecutively, has the same operations and uses a different key. Each round uses a combination of proper substitution, where we take some bits which are substituted with another combination of bits. Each DES round takes as an input the ciphertext produced by the previous round and outputs the ciphertext for the next round. The input is divided into a left half and a right half. The output left half is just the right half of the input. The right output is the result of XOR-ing the left half of the input and the output of the Mangler Function (which takes as an input the 32-bit right half, expands it to 48-bit (bit-wise operation) then XORs it to 48-bit key, then uses the S-Boxes to substitute the 48-bit value into a 32-bit value).
The algorithm process of decryption in DES is the same as the encryption process. It uses the ciphertext as an input to DES but the keys are run in reversed order, i.e. k = 16 is used as the first round of decryption, k = 15 is used as a second round of decryption and so on, so forth. 
Diffusion is one of the principles in encryption. It is achieved through permutation (initial transposition). Permutation works by changing the position of the bits in DES. The mixed bits are taken to a sub-box which receives the 56-bit key and the 64-bit plaintext, once it completes processing, it outputs the 64 bits into another transposition subsection, which in turn produces a 64-bit ciphertext. 
The larger the block size, the key size and number of rounds means greater security. However, when there are more than 16 rounds or more than 56 keys, the security will neither be increased nor the encryption will be made any stronger. The possible attacks that often occur on product ciphers are differential cryptanalysis and linear cryptanalysis, however, according to Stallings, DES has proven to be resistant to these sort of attacks \cite{stallings2011-a}. By 1999, a computer could try every possible key in a couple of days rendering the cipher insecure.

\subsection{Design ($\pm$ 20\% total words)}

The technical part of our project consists of creating a chat application. Our source code editor is Visual Studio Code and we program in Python. We create a TCP server as well as a TCP client that connects to the server. 
For the client to use TCP Networking, we require a socket module, imported beforehand from Python's standard library, that serves as a communication endpoint with two parameters:
s= socket.socket(socket.AF\_INET, socket.SOCK\_STREAM)
the first parameter AF\_INET stands for IPv4, the connection type we want to use, and the second parameter \textit{SOCK\_STREAM} means we are going to use TCP connection. We specify a variable for port number (on which the server is running) and ip, which holds the ip of the host machine it is running on. We use \textit{gethostbyname} to look for the host’s ip since the host machine does not have a fixed IP address and often when it reconnects to an Internet connection is assigned a new IP address.
\textit{ip = str(socket.gethostbyname(socket.gethostname()))}
\textit{port = 1234}
Once we the port and ip address are known, we can connect to the server by passing the function to a data structure \textit{s.connect(((ip, port))}

For the server to use TCP Networking, we require a socket module that serves as a communication endpoint with two parameters:
\textit{s= socket.socket(socket.AF\_INET, socket.SOCK\_STREAM)}
For the client to work, a port number equal to 1234 is specified equal to the server’s so that both can connect. When the port and host have been bounded, we can listen to incoming connections with socket variable s and calling listen on it: \textit{s.listen(10)}. We pass the variable 10 which means that up to 10 people can be queued for us to handle the requests. However, the eleventh will be rejected. To accept requests from outside, we use connection variable and address variable as: \textit{conn, addr = s.accept()} which stores the ip import of the client trying to connect and we call accept on the socket we have created. Upon a connection being established, the client can send messages to the server that will cause it to echo back the message. The server can receive data from client by creating variable data and sending it to the response gathered from connection. We write: \textit{incoming\_message = conn.recv(4096)}. Afterwards we can close the connection between client and server \textit{conn.close()}, on the server side, as well as close the socket itself as it allows connections to exist, on the client side, \textit{s.close()}.
For our project, we aim at implementing in Python several encryption and decryption applications. The client stores the encryption algorithms, whereas the server holds the decryption methods. We make use of Caeser Cipher, ROT13, DES and AES.
DES and AES have been implemented through the means of the crypto library “PyCryptodome”. It is a self-contained Python package of low-level cryptographic primitives \cite{pycryptodome}. It supports PyPy, Python2 and Python3. PyCryptodome can be used as a replacement for the old PyCrypto library. We install all modules under Crypto package with pip3 install pycryptodome.  However, having both PyCrypto and PyCryptodome installed at the same time is not a good idea as they will interfere with each other. If, however, one insists on having them both, it would be best to deploy them in a virtual environment. To have an independent library of the old PyCrypto, it suffices to type the following command in Terminal shell:\textit{pip3 install pycryptodomex} and all modules are installed under Cryptodome package and PyCrypto and PyCryptodome can coexist. 


\subsection{Production ($\pm$ 20\% total words)}

We implement all algorithms with Python programming language. 

Caeser cipher is a substitution cipher and a type of shift cipher. Shift ciphers work by using the modulo operator to encrypt and decrypt messages. In the following lines we demonstrate its algorithm. We take an alphabetic message (A to Z). We take a key, an integer from 0 to 25,since there are 26 letters in English alphabet, to be equal to 3.To encrypt, we do a right-shift letter by letter by the value of key mod 26. To decrypt, a left-shift of the message letter by letter is performed, subtracting the value of key and taking the modulus 26. Our code can be presented as follows: for every letter (char) in the message, we find the letter that matches its position in the alphabet starting from 0. We calculate \textit{newPosition = (position + key) mod 26}, then convert \textit{newPosition} into a letter that matches its order in the alphabet starting from 0. The decryption process is similar; however, instead of adding the key, we subtract it during the modular operation.

ROT13 is a special case of Caeser cipher. ROT13 is implemented by setting the value of the key to 13. The key is used by both encryption and decryption algorithms. The \textit{ord()} function returns an integer representing the Unicode code point of a character string. For example, \textit{ord('z')} returns the integer 122. 32 implies empty space in ASCII, hence, we check for empty space with \textit{if ord(message[i] == 32)}. Since we are working with uppercase letters, in the \textit{encrypt\_rot13()} function, we check if our variable temp is bigger than the integer 90, which corresponds to uppercase Z. If so, we subtract 26 and move back to A. We note that lowercase letters under ASCII map from 97 to 122. The \textit{chr()} function is the opposite of \textit{ord()}. It returns the string character whose Unicode code point is an integer. For instance, \textit{chr(122)} returns string ‘z’. In decrypt\_rot13() function we verify if our variable temp is less than uppercase A and if so, we add 26 to it and move back to uppercase Z. In ASCII, Unicode code points less than 65 are various symbols. The \textit{decrypt()} functions differs from \textit{encrypt()} by the fact that we subtract the key to get our variable temp. 

To implement DES, we import DES functional dependency from Cryptodome library module. Then we create and specify a fixed \textit{key = “mysecret”} of length 8 bytes, a password that shall be used to encrypt the text. We have created a pad function, \textit{despad} taking as input \textit{text}. Whatever we type for the text parameter, the pad function shall operate on the text. We run a while loop checking the length of text mod 8, i.e. the modulus divides it and shows the remainder. If remainder is not equal to zero, we add a space at the end of text such that it becomes multiple of 8 (e.g. 8, 16, 24, 32, etc.), otherwise the encryption is not going to work as DES encryption algorithm takes input in 8 bytes. For instance, if we type ‘abcd’ it is not going to work, hence, the function adds 4 empty spaces at the end of ‘abcd’ to make sure it is a total of 8 characters/bytes. Then, we create an object, called \textit{des}. We use \textit{new()} function of module DES that takes two parameters: key and \textit{DES.MODE\_ECB} which is the encryption mode. We have created a variable taking an input from client that shall be encrypted. The \textit{padded\_text} variable uses the despad() function on the client's input to make sure it is a multiple of 8 and if necessary adds empty spaces to conform to the multiple condition. Next, we have created an \textit{encrypted\_text} variable that uses the \textit{encrypt()} function on the \textit{padded\_text} and turns it into an encrypted string. To represent ciphertexts, it is more readable to use hex strings rather than bytes. Moreover, hex() makes it easier to parse the decryption input, implemented in the server. To be sure that data remains intact without modification during transfer from client to server, we need to encode it. To reverse the process, the server needs to decode the message. In order to decrypt, we run des submodule and pass \textit{decrypt()} function on it. Since we have used padding before encryption, we need to unpad the recovered cleartext by using rstrip(). 

AES has been implemented using the \textit{PyCryptodome} library. We import the module AES along with the hash package and hash object \textit{SHA-256}. In function \textit{make\_key()}, SHA-256 produces a 256-bit digest of the password, aka key. Digest() returns a binary digest of the message that has been hashed. Since \textit{digest()} produces a random output it is impossible to derive the original input data. On the client side, the \textit{aesencrypt()} function has a pad variable which appends to the back as many bytes we need to reach the next 16-byte boundary, before encrypting the bytes message. On the server side, an unpad function is used to reverse the padding executed before encryption. The \textit{block\_size} is the size of the message block in bytes. The IV (initialization vector) is a unique and random piece of data used to initialize the processing. This setting does not allow an attacker to get relations between encrypted messages segments. The iv need not be private so that we can send it with the ciphertext without risk. Its length is equal to 16 bytes. Since, AES is symmetrical, it uses the same key for encryption and decryption. The key and IV have been loaded on separate files and are used for both operations. The iv is written and overwritten each time it is used to encrypt a message on file. And it is being read from the file during decryption. The type of files is .dat and not .txt because .dat, a binary text file, can store (unreadable) data that differs from plaintext and is not always printable on screen. We could not print the iv after attempting to load it on a .txt file. We came to the conclusion that it is due to the fact that the iv is unique, written in 16 bytes, and may contain not only readable data but unreadable as well. We observe that the key is private and is reused to encrypt multiple plaintexts, but coupled with the mode of operation CBC (Ciphertext Block Chaining), where the IV is randomly generated for each new message, we can encrypt a lot of data under the same key. CBC requires the length of plaintext and ciphertext to be always a multiple of 16 bytes. The \textit{new()} function instantiates a new object for the AES algorithm. It has 3 parameters: key (in bytes), mode \textit{(MODE\_CBC)} and iv (in bytes as a read-only attribute). The new() function returns a CBC cipher object. To encode and decode the message, base64 has been used. It allows to transfer over a medium relying on textual data by converting from binary data to text strings and vice versa. The method \textit{encrypt()} (and likewise \textit{decrypt()}) of a CBC cipher object expects data to have length multiple of the block size, i.e. 16 bytes for AES. The message is being translated from a Unicode string into a sequence of bytes through UTF-8 (Unicode Transformation Format) encoding. \textit{Encode(“utf-8”)} and \textit{Decode(“utf-8”)} return byte representations of the Unicode string, encoded in UTF-8.

\subsection{Assessment ($\pm$ 15\% total words)}
Provide any objective elements to assess that your deliverables reached or not the requirements described above. 
\section*{Acknowledgment}
The authors would like to thank the BiCS management and education team for the amazing work done.