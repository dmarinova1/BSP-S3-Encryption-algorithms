\section{BSPro - A First Bachelor Semester Project in BiCS-land}
\subsection{Requirements ($\pm$ 15\% total words)}
[[[[Describe here all the properties that characterize the deliverables you produce. It should describe what are those deliverables, who are the actors exploiting the deliverables, what are the expected functional and non functional qualities of the deliverables.]]]]

Ciphers have been used long before apparition of computers. During Roman times, Julius Caesar invented an encryption for his private correspondence. Today, it is known as the Caesar cipher. Given the English alphabet, the cipher shifts a letter from the alphabet three places to the right, i.e. A is encrypted as D, B as E,etc. It is a monoalphabetic cipher. To decrypt the message, the other party needs to know both the algorithm and the shifting number. The secret key shared by the sender and the recipient of the message is k=3. Breaking the Caesar Cipher can be done by testing all possible shifts. Since an alphabet of length 26 is used we have to test 26 shifts. 

ROT13 is a simple monoalphabetic substitution cipher, a special class of Caesar cipher, that encodes a certain letter with another letter that is 13 positions after it. Only those letters which occur in the English alphabet are affected. Numbers, symbols, whitespace, and all other characters are left unchanged. It is an example of a cipher providing weak encryption, since both operations encryption and decryption are identical. Hence, this cipher is its own inverse. Because we know there are 26 letters in the English alphabet, if we wish to apply twice 13 it would give us one shift of 26. Thus, it leads us back to the original text. Moreover, the direction of the shift is of no importance, since it will always give the same output \cite{swenson2008modern}.
ROT13 is used in online forums as a means of hiding spoilers, punchlines, puzzle solutions, and offensive materials from the casual glance. Furthermore, it has inspired a variety of letter and word games online \cite{wikirot13}. 

Another cipher our project deals with is the block cipher Data Encryption Standard (DES). In DES we put 64-bit block of plaintext,  DES' key (which does the processing) is 64 bit which is 8 bytes but for each byte there is one parity bit, therefore, the value in the key is only 56 bits which means there are 2 to the power of 56 different keys. The output ciphertext is a 64-bit block. 
From the 56-bit key, 16 bits are generated (one for each round). Each DES round works consecutively, has the same operations and uses a different key. Each round uses a combination of proper substitution, where we take some bits which are substituted with another combination of bits. Each DES round takes as an input the ciphertext produced by the previous round and outputs the ciphertext for the next round. The input is divided into a left half and a right half. The output left half is just the right half of the input. The right output is the result of XOR-ing the left half of the input and the output of the Mangler Function (which takes as an input the 32-bit right half, expands it to 48-bit (bit-wise operation) then XORs it to 48-bit key, then uses the S-Boxes to substitute the 48-bit value into a 32-bit value).
The algorithm process of decryption in DES is the same as the encryption process. It uses the ciphertext as an input to DES but the keys are run in reversed order, i.e. k = 16 is used as the first round of decryption, k = 15 is used as a second round of decryption and so on, so forth. 
Diffusion is one of the principles in encryption. It is achieved through permutation (initial transposition). Permutation works by changing the position of the bits in DES. The mixed bits are taken to a sub-box which receives the 56-bit key and the 64-bit plaintext, once it completes processing, it outputs the 64 bits into another transposition subsection, which in turn produces a 64-bit ciphertext. 
The larger the block size, the key size and number of rounds means greater security. However, when there are more than 16 rounds or more than 56 keys, the security will neither be increased nor the encryption will be made any stronger. The possible attacks that often occur on product ciphers are differential cryptanalysis and linear cryptanalysis, however, according to Stallings, DES has proven to be resistant to these sort of attacks \cite{stallings2011-a}. By 1999, a computer could try every possible key in a couple of days rendering the cipher insecure.

\subsection{Design ($\pm$ 20\% total words)}

The technical part of our project consists of creating a chat application. Our source code editor is Visual Studio Code and we program in Python. We create a TCP server as well as a TCP client that connects to the server. 
For the client to use TCP Networking, we require a socket module that serves as a communication endpoint with two parameters:
s= socket.socket(socket.AF_INET, socket.SOCK_STREAM)
the first parameter AF_INET stands for IPv4, the second parameter \textit{SOCK_STREAM} means we are going to use TCP. We specify a variable for port number (on which the server is running) and ip, which holds the ip of the host machine it is running on. We use \textit{gethostbyname} to look for the host’s ip since the host machine does not have a fixed IP address and often when it reconnects to an Internet connection is assigned a new IP address.
\textit{ip = str(socket.gethostbyname(socket.gethostname()))}
\textit{port = 1234}
Once we the port and ip address are known, we can connect to the server by passing the function to a data structure \textit{s.connect(((ip, port))}

In the Python script for the server, we turn the connections into threads creating a multithreaded server. A thread is an external process and we can have many running simultaneously. This facilitates the whole process when there are many clients that connect to the server. We import the thread library import threading. We create an EchoThread class and pass to its function a connection and address. For the server to use TCP Networking, we require a socket module that serves as a communication endpoint with two parameters:
\textit{s= socket.socket(socket.AF_INET, socket.SOCK_STREAM)}
There is also a callback to every connection established to that server with variable “conn”, short for connection. It describes information about the connection. TCP allows us to open a connection, execute some data transfer on it without even closing the connection which may stay open for a long period of time. We subscribe to two events. The first one is data and second one is closing the connection. For the data event, each time data is sent over to the server, data is received by the client. Once the client cuts the connection or the EchoThread is terminated, the connection is ended.
For the client to work, a port number is specified equal to the server’s so that both can connect. When the port and host have been bounded, we can listen to incoming connections with socket variable s and calling listen on it: \textit{s.listen(10)}. We pass the variable 10 which means that up to 10 people can be queued for us to handle the requests. However, the eleventh will be rejected. To accept requests from outside, we use connection variable and address variable as: \textit{conn, addr = s.accept()} which stores the ip import of the client trying to connect and we call accept on the socket we have created. Upon a connection being established, the client can send messages to the server that will cause it to echo back the message. The server can receive data from client by creating variable data and sending it to the response gathered from connection. We write: \textit{data = conn.recv(4096)}. Then server sends that message to all connected clients \textit{conn.sendall(data}. Afterwards we can close the socket connection between client and server \textit{print("connection closed with ", addr)} as well as close the socket itself \textit{s.close()} that allows connections to exist.
For our project, we aim at implementing in Python several encryption and decryption applications. We make use of Caeser Cipher, ROT13, DES and AES.
DES and AES have been implemented through the means of a crypto library “PyCryptodome”. It is a self-contained Python package of low-level cryptographic primitives. It supports PyPy, Python2 and Python3. PyCryptodome can be used as a replacement for the old PyCrypto library. We install all modules under Crypto package with pip3 install pycryptodome.  However, having both PyCrypto and PyCryptodome installed at the same time is not a good idea as they will interfere with each other. If, however, one insists on having them both, it would be best to deploy them in a virtual environment. To have an independent library of the old PyCrypto, it suffices to type the following command in Terminal shell:\textit{pip3 install pycryptodomex} and all modules are installed under Cryptodome package and PyCrypto and PyCryptodome can coexist. 


\subsection{Production ($\pm$ 20\% total words)}

We implement all algorithms with Pythong Programming language. 

Caeser Cipher is a substitution cipher and a type of shift cipher. Shift ciphers work by using the modulo operator to encrypt and decrypt messages. In the following lines we demonstrate its algorithm. We take an alphabetic message (A to Z). We take a key, an integer from 0 to 25, equal to 3.To encrypt, either left-shift or right-shift letter by letter by the value of key. For instance, if message is ABC and key K is 3, we perform right-shift and the encrypted text is A + 3 = C, B+3 = E, C+3 = F, hence, CEF. To decrypt, left-shift or right-shift the message letter by letter opposite to the shift performed in encryption by the value of key. For example if encrypted text is "CEF" and key is 3 and we are performing left-shift then encrypted text will be C-3 =A , E-3 =B B, F-3 = C, hence, ABC being decrypted text. 
For every letter (char) in the message, we find the letter that matches its order in the alphabet starting from 0. We calculate \textit{newPosition = (position + key) mod 26}, then convert \textit{newPosition} into a letter that matches its order in the alphabet starting from 0. The decryption process is similar; however, we subtract the key during the modular operation.

To implement DES, we import DES function from Cryptodome library module. Then we create and specify a \textit{key = “mysecret”}, a password that shall be used to encrypt the text and is 8 bytes long. We have created a pad function taking as input text. Whatever we type for the text parameter, the pad function shall operate on the text. We run a while loop checking the length of text mod 8, i.e. the modulus divides it and shows the remainder. If remainder is not equal to zero, we add a space at the end of text such that it becomes multiple of 8 (e.g. 8, 16, 24, 32, etc.), otherwise the encryption is not going to work as DES encryption algorithm takes input in 8 bytes. For instance, if we type ‘abcd’ it is not going to work, hence, the function adds 4 empty spaces at the end of ‘abcd’ to make sure it is a total of 8 characters/bytes. Then, we create an object, called ‘des’. We use \textit{new()} function of module DES that takes two parameters: key and \textit{DES.MODE_ECB} which is the encryption mode. We have created a variable taking an input from client that shall be encrypted. The \textit{padded_text} variable uses the pad() function on the input to make sure the input provided by client is a multiple of 8 and if necessary adds empty spaces to conform to the multiple condition. Next, we have created an \textit{encrypted_text} variable that uses the \textit{encrypt()} function on the \textit{padded_text} and turns it into an encrypted string. In order to decrypt, we run des submodule and pass decrypt() function on it. 



\subsection{Assessment ($\pm$ 15\% total words)}
Provide any objective elements to assess that your deliverables reached or not the requirements described above. 
\section*{Acknowledgment}
The authors would like to thank the BiCS management and education team for the amazing work done.