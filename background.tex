\section{Background ($\pm$ 15\% total words)}
\subsection{Scientific}

In this section we present substitution and transposition ciphers along with stream and block ciphers. On the one hand, substitution ciphers they take the i-th element of a string and change it for another value to produce a ciphertext. Substitution ciphers can be monoalphabetic or polyalphabetic. The former, also called simple substitution cipher, maps a plaintext letter to a ciphertext letter based on a single alphabet key. The latter uses multiple substitution alphabets. In transposition ciphers the values of plain letters are not changed for another but rearranged. Modern ciphers use a combination of both substitution and transposition ciphers. Ciphers can also be divided into stream and block ciphers. The former convert one symbol (1 bit or byte) of plaintext directly into a symbol of ciphertext. The latter encrypt a group of plaintext symbols as one block and outputs a block of ciphertext. We add that substitution ciphers can operate on either blocks or streams. 

In the rest of the section, we describe different examples of ciphers for each of the groups presented above.

\textbf{Substitution ciphers:} 
The most popular example of substitution cipher is the One - Time Pad (OTP), designed in 1917. What makes it very secure is that a pad (secret key) is never reused. Instead, OTP utilizes a random key which has an equal length to the message. It shifts each plain letter depending on the corresponding keyword letter. The random key is also used in encryption and decryption of the message, and afterwards is discarded \cite{stallings2011}. If we want to generate a new message, a new key is required. Thus, this scheme leads to an output unrelated to the plaintext. If we try to decipher a ciphertext using this method, and let us suppose we have succeeded in finding the key, our attempts would lead us to fairly different decrypted outputs. For this reason, it would be difficult to decide upon the correct decryption. However, there are two fundamental complexities related to the one-time pad: (1) making large quantities of random keys; (2) key distribution and protection (since a key of equal length is needed by both sender and receiver)\cite{stallings2011}. Hence, if we ought to employ the one-time pad, it would be best for low-bandwidth channels requiring very high security \cite{stallings2011}. Nevertheless, this cryptosystem is regarded as the sole exhibiting perfect secrecy \cite{stallings2011}. Some cipher machines attempted mechanically then electronically, in both cases nevertheless unsuccessfully, to create approximations to one-time pads (OTPs). Many snake oil algorithms claim to be unbreakable, posing as OTPs. Hence, these algorithms give rise to pseudo-OTPs providing pseudo-security \cite{curtin1998}.

How does a substitution cipher work? In order to produce the ciphertext, the cipher modifies characters in the plaintext. Can it be broken? We can break the monoalphabetic cipher by using letter frequency analysis since letter frequencies are preserved (e.g. 'e is the most common letter in English, followed by 't,i,o,a,n,s,r '). The polyalphabetic cipher can be broken by decomposing into individual alphabets and as a consequence to treat it as a simple substitution cipher. A historical example of breaking the substitution cipher is the execution of Mary, Queen of Scots, in 1587 for plotting to kill Queen Elizabeth \cite{maryscots}. The "Vigenere Cipher" is the most popular polyalphabetic cipher. The Vigenere cipher is an improvement of the Caesar cipher but not as secure as the unbreakable One Time Pad. Caesar cipher encodes each plain letter by a constant shift, whereas the One Time Pad shifts each plain letter depending on the corresponding keyword letter. The Vigenere cipher uses a keyword of given length repeatedly to determine the encoding shift of each plain letter. For instance, we are given a word, we convert it to numbers, according to the letter position in the alphabet. Next, we repeat the sequence of numbers along the message. Then, we encrypt each letter in the message by shifting, according to the number below it, and send the encrypted message openly to the recipient. Hence, we employ multiple shifts. To decrypt the message, we should subtract the shifts according to the secret word or key we have a copy of.

\textit{Cipher machines}: Cryptography was mechanized by the 1900s in the form of encryption machines. The basic component of a cipher machine is the wired rotor. When we get prior to the Second World War, the Germans realized that, thanks to radios, messages can be sent across the battlefield in an instant but that always meant the other side could also tap into those radio channels. Therefore high-tech encryption was highly needed. The Germans invented Enigma,whose complexity guaranteed their privacy. The Enigma was a substitution cipher, but a more sophisticated one because it used three rotors in a row, each feeding into the next. The Germans typed their messages on a keyboard that came out as gibberish on a lampboard. Then they sent it over the radio to the other side, which also has the same Enigma machine to help them decrypt the unintelligible message. Furthermore, to decrypt the message, it is assumed that the other side should know the algorithm and must have configured the machine the same way as the Enigma machine encrypting the message. The Enigma relies on a random letter generator. Hence, its encryption does not seem to follow any kind of pattern. There are 26 wires coming out of the keyboard, running through three rotors with 6 permutations, going into the lamps representing the output letter. Once the first of the three rotors hits a full evolution, it kicks the next rotor to start moving, yet again, when it completes its cycle, it transmits the process to the last rotor. The inside of the rotors resembles scrambled wiring. A rotor's side has 26 junctions or contacts, accepting the incoming wires and outputting them to the other side of the rotor. The rotor moves each time a letter is typed in. Even if the same letter is passed sequentially, the rotor would move and a lamp representing a different output letter would light up. Thus, the dynamism of the rotors accounts for the complicated encryption. Finally, a plugboard at the front of the machine allows letters to be optionally swapped so that the machine it is interacting with is configured the same way. Alan Turing and his colleagues at Bletchley Park were able to break the Enigma codes and automate the process by developing a new machine called \textit{the Bombe} \cite{alanturing}. The rotor machines were cracked because the same key had been used over an extended period of time and due to the use of old compromised keys while encrypting. In addition, the circuit's configuration showed that it was impossible for a letter to be encrypted as itself, which turned out to be a cryptographic flaw. 

\textbf{Transposition ciphers:} Another kind of mapping is achieved by performing permutation on the plaintext letters. This technique is referred to as a transposition cipher. For example, a simple cipher of this sort is the rail fence technique. The plaintext is written as a sequence of diagonals and read off as a sequence of rows. The key is the number of rows used to encode. 

With today's computer power transposition ciphers can be broken quickly. Trying to compute the frequencies of the cipher letters is one method. Another way is testing possible rearrangements. For instance, one may try to read the cipher text backwards. If that does not yield the plain text then the rail fence technique could be tested. If that does not yield the plain text, one could check if two consecutive letters were switched.    

\textbf{Stream ciphers:} A stream cipher generates a stream of bytes, one for each byte of the text we want to encrypt.  An example is Rivest Cipher 4 (RC4), designed in 1987 by Ron Rivest. RC4 uses either 64-bit or 128-bit key sizes. Its most popular implementation is in WEP for 802.11 wireless networks and in SSL. RC4 consists of a key-scheduling algorithm, which initializes a permutation of all 256 possible bytes (since the permutation array has a length of 256 bytes) \cite{stallings2017}. The permutation itself is started with a length key between 40 and 2048 bits. RC4 is also composed of pseudo-random generation algorithm (PRGA) which generates the stream of bits. PRGA has two 8-bit index pointers (i and j) on which, during the 256 iterations, it executes operations such as XOR-ing, swapping, modulo. Stream ciphers are vulnerable to attacks, mostly to bit-flipping \cite{wikirc4} . Bit-flipping attack deals with changing a bit in a ciphertext so that it results in a predictable plaintext. It is not targeting the cipher itself but a message or a series of messages on a channel. For this reason, it could turn into a Denial of Service attack. We should never reuse a key with a stream cipher. The main reason being that we can recover the plaintext, using the keystream and the ciphertext. The keystream could be recovered as well using the plaintext and the ciphertext. Furthermore, if we use two ciphertexts from the same keystream, we can recover the XOR-encryption of the plaintexts.

\textbf{Block ciphers:} Block ciphers date back to late 1960s when IBM attempted to develop banking security systems \cite{ibmcrypto}. The result was Lucifer, an encryption method, with 128-bit key and block size, aimed at protecting data for cash-dispensing system in the UK. However, it was not secure in any of its version implementations. 
When we use block ciphers, each block is encrypted independently producing a ciphertext block of equal size. The block size can be 64-bits, 128-bits or 256-bits. The ciphertext is generated from the plaintext and the key by iterating a \emph{round function} (as we go through it several times). Input to the round functions consists of key and the output of previous round. Block ciphers are also known as \emph{product} ciphers and are built with a \emph{Feistel structure}, as first described by Horst Feistel of IBM in 1973. The plaintext is split into left and right halves. The Feistel design consists of a number of identical rounds of processing. During each round, substitution is performed on one half of the processed data, followed by a permutation that interchanges the two halves. What is more, the original key is expanded so that a different key is used for each round. Symmetric block encryption algorithms are based on this structure. In general, it is accepted that block ciphers are applicable to a broader range of applications in software as opposed to stream ciphers.

When we want to encrypt longer than a 16-byte plaintext (email, file, etc.) with a symmetric key block cipher algorithm, there exist several modes of operation:
\begin{itemize}
\item ECB (Electronic Code Book mode)
\end{itemize}
\begin{itemize}
\item CBC (Cipher Block Chaining mode)
\end{itemize}
\begin{itemize}
\item CFB (Cipher Feedback mode) 
\end{itemize}
\begin{itemize}
\item OFB (Output Feedback mode)
\end{itemize}
\begin{itemize}
\item CTR (Counter mode)
\end{itemize}
These modes aim at providing confidentiality and protection for sensitive data. The latter three modes use the block cipher as a building block for a stream cipher \cite{springer2010}. To encrypt data with DES and AES our project utilizes ECB and CBC modes, respectively. ECB requires that the length of the plaintext is a multiple of the block size of the cipher used. If the plaintext does not conform to the required length, it must be padded. Padding is achieved by appending as many zero bits as possible in order to reach a multiple of the block length (i.e. 8, 16, 32, etc.). In case the plaintext conforms to the length, an extra block is appended consisting of only padding bits. Furthermore, in ECB mode each block is encrypted separately. One of the advantages of ECB is that if a transmission problem occurs, the received encrypted block could still be decrypted \cite{springer2010}. Moreover, parallelization is allowed in ECB mode, i.e. one encryption unit encrypts block 1, the next one block 2, etc., which is useful in high-speed implementations \cite{springer2010}. Nevertheless, there are some weaknesses associated with the ECB mode. During encryption identical plaintext blocks result in identical ciphertext blocks as long as the key does not change \cite{springer2010}. Hence, an attacker could easily deduce information. The ECB mode is susceptible to substitution attacks because once block mapping from plaintext to ciphertext is known, a sequence of ciphertexts can be manipulated \cite{springer2010}. 
With regard to CBC, all encrypted blocks are chained together such that a certain ciphertext depends not only on a certain block but on all previous plaintext blocks as well \cite{morris2001}. Each plaintext block also gets XORed with the previous ciphertext block prior to encryption \cite{morris2001}. In addition, the encryption is randomized by using an initialization vector (IV). In our case, the IV is new every time we encrypt and is always incremented when a new session starts. If we encrypt a string once with a first IV and a second time with a different IV, the two resulting ciphertext sequences look completely unrelated to each other. To strengthen the encryption method, a mode of operation is used, for AES we have chosen CBC mode. 

\textit{DES}: Cryptography gradually moved from hardware to software with the advent of computers. Most famous example of the block cipher design and the classic Feistel structure is the Data Encryption Standard (DES), designed by IBM under the advisement of NASA in 1977 and standardized 2 years later. It was meant to encipher sensitive but non classified data. DES complexity is comprised of a simple repetition of the primitives of transposition, substitution, split, concatenation and bit-wise operation. DES uses a 56-bit key. The cipher is thoroughly examined in section 4 of this report for it has been used during our hands-on approach.

\textit{TRIPLE DES (3DES)}: has replaced DES since the simpler version is susceptible to brute force attacks. 3DES is a more secure method of symmetric- key encryption, as it encrypts data three times in contrast to DES, i.e. the one 56-bit key becomes three individual keys rendering a 168-bit key. However, initiating three instances of DES, implies that 3DES is much slower than other methods of encryption. The text is encrypted firstly with key 1, then decrypted with key 2 and lastly encrypted once more by key 3. Triple DES offers a security level of $2^{112}$ instead of $2^{168}$,i.e., with only two keys of encryption, since the 168-bit key can be cumbersome to implement. This method is known as Encrypt-Decrypt-Encrypt (EDE): key 1 encrypts the message; then the message is decrypted using key 2, afterwards the text is encrypted again with key 2. We should mention that there exists double DES as well, which is composed of two successive instances of DES. 2DES offers a security level of $2^{57}$ instead of $2^{112}$ due to the cryptographic attack, called \emph{meet-in-the-middle} \cite{mitm}. If we take some plaintexts and encode them and at the same time take some encrypted values and start decrypting them, we only have to look for where they meet in the middle with the same value. Those intersections then reveal the key. 3DES avoids this as we would need to perform a third operation to tell if they met in the middle. Thus, it is not enough to look for where the first and last operation produce the same value.

\textit{AES}: The Advanced Encryption Standard (AES) replaced DES in 2000 as the US Government encryption technique to protect classified information. The symmetric block cipher was developed by two Belgian cryptographers Joan Daemen and Vincent Rijmen. AES was designed to be efficient in both hardware and software. Again, it is thoroughly described in section 4 of the report.

\subsection{Technical}

One of the deliverables of this project is a chat system implemented in Python. The application employs ciphers reviewed in this report to encrypt messages. Python is a programming language created by Guido van Rossum in late 1980s in the Netherlands. Python is a free software and the latest version can be downloaded from \url{www.python.org}. Python is a simple and very powerful general purpose computer programming language. This allows for the language to remain fresh and current with the newest trends. Python has libraries for just about everything. It can be used for web development, web scraping, writing scripts, browser automation, GUI development, data analysis, machine learning, computer vision, and game development, etc. In addition, Python is an object-oriented programming language (OOP). There are four pillars of OOP: encapsulation, abstraction, inheritance, and polymorphism. Before turning to OOP, there is procedural programming, a simple and straightforward programming, that divides a program into a set of functions. However, as our program grows we end up with \emph{spaghetti code}, i.e. many functions all over the place that are interdependent. Thus, OOP offers a solution to this issue. We can bundle a group of related variables (referred to as \emph{properties}) and functions that operate on them (referred to as \emph{methods}) into an object. This grouping is called \emph{encapsulation}. Using this technique, we can reduce complexity and increase reusability. In Python, objects are data and have a certain type (integer, float, list, etc.). Once we have created our objects we can manipulate and interact with them (append, sort, delete, concatenate, etc.). We can hide the details and complexity (e.g. some methods and properties) from the outside and show only the essentials through the process of \emph{abstraction}. This is beneficial as we produce simpler interface and reduce the impact of change (i.e. no inner changes leak to the outside of the contained object). \emph{Inheritance} is a mechanism that allows us to eliminate redundant code. \emph{Polymorphism} is a technique that allows us to refactor long if/ else or switch/case statements. 

Our platform is macOS and we can open Python on a Terminal. Moreover, we can use any Text Editor or IDLE of our choice. For this project, we have used the source code editor Visual Studio Code (VSC) developed by Microsoft. VSC is a lightweight yet powerful editor. It offers support for debugging, embedded Git control, syntax highlighting, snippets, extensions, smart code completion and code refactoring. A GitHub repository was set up to share and build our project. The link is provided in the annex of the report. GitHub is a web-based hosting service of open source projects for version control using Git. 

To build the chat program for our project we need a client and a server. To establish a connection between both and be able to transmit information back and forth over the Internet, we need a socket link. Sockets aid the communication between these two entities. The client requests information from the server and the server carries out data to the client. Similarly, the client is a program as well. However, altogether, they are referred to as \emph{client/server architecture}. For instance, when we visit a website, we are using a socket and accessing a port of the web server. In this case, the server has generally port 80 open, used to transfer HTTP data. Other websites have ports 21 and 20 open for FTP access, which is not very secure, some have port 22 intended for SSH. The lower number ports are specific ports, whereas the higher number ports signify general purpose rights. More often than not, questions arise regarding security when using higher number ports. 

Our client should send an initial request to the server's port number, \emph{the listening port}. To keep the communication over TCP (valid for every other protocols as well), we have the client's IP address and local port number as well as the server's IP address along with its port number. Each client that connects to the server gets unique set of values of two IP addresses and two port numbers in a tuple, a collection of items. 