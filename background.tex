\section{Background ($\pm$ 15\% total words)}
\subsection{Scientific}

In this section we present substitution, transposition, stream and block ciphers.

\textbf{Substitution ciphers:} 
Ciphers have been used long before apparition of computers. During the Ancient Rome times, Julius Caesar invented an encryption for his private correspondence. Today, it is known as the Caesar cipher. Given the English alphabet, the cipher shifts a letter from the alphabet three places further down. To decrypt the message, the other party needs to know both the algorithm and the shifting number. 

ROT13 is a simple monoalphabetic substitution cipher, a special class of Caesar cipher, that encodes a certain letter with another letter that is 13 positions after it. Only those letters which occur in the English alphabet are affected. Numbers, symbols, whitespace, and all other characters are left unchanged. It is an example of a cipher providing weak encryption, since both operations encryption and decryption are identical. Hence, this cipher is its own inverse. Because we know there are 26 letters in the English alphabet, if we wish to apply twice 13 it would give us one shift of 26. Thus, it leads us back to the original text. Moreover, the direction of the shift is of no importance, since it will always give the same output \cite{swenson2008modern}.
ROT13 is used in online forums as a means of hiding spoilers, punchlines, puzzle solutions, and offensive materials from the casual glance. Furthermore, it has inspired a variety of letter and word games online \cite{wikirot13}. 

The most popular secure example of substitution ciphers is one - time pad, designed in 1917. It is employed by Russian spies, the CIA covert operations and the \emph{hotline} Washington-Moscow. A pad (secret key) is never reused. Instead, it utilizes a random key which has an equal length to the message. The random key is also used in encryption and decryption of the message, and afterwards is discarded \cite{stallings2011}. If we want to generate a new message, a new key is required. Thus, this scheme leads to an output unrelated to the plaintext. If we try to decipher a ciphertext using this method, and let us suppose we have succeeded in finding the key, our attempts would lead us to fairly different decrypted outputs. For this reason, it would be difficult to decide upon the correct decryption. According to Stallings, there are two fundamental complexities related to the one-time pad: (1) making large quantities of random keys; (2) key distribution and protection (since a key of equal length is needed by both sender and receiver). Hence, if we ought to employ the one-time pad, it would be best for  for low-bandwidth channels requiring very high security \cite{stallings2011}. Nevertheless, this cryptosystem is regarded as the sole exhibiting perfect secrecy \cite{stallings2011}. Cipher machines, presented below in this report, attempted unsuccessfully, first mechanically, then electronically, to create approximations to one-time pads (OTPs). Many snake oil algorithms claim inability to break by claiming to be OTPs, hence, giving a rise to pseudo-OTPs providing pseudo-security \cite{curtin1998}.

In order to produce the ciphertext, a substitution cipher modifies characters in the plaintext. There are two types of substitution ciphers: simple and polyalphabetic. We can break the former by using letter frequency analysis since letter frequencies are preserved (e.g. E is the most common letter in English). The latter can be broken by decomposing into individual alphabets and as a consequence to treat is as a simple substitution cipher. A historical example of breaking the substitution cipher is the execution of the Queen of Scots, Mary, in 1587 for plotting to kill Queen Elizabeth \cite{maryscots}.

\textbf{Transposition ciphers:} Another kind of mapping is achieved by performing permutation on the plaintext letters. This technique is referred to as a transposition cipher. For example, a simple cipher of this sort is the rail fence technique, in which the plaintext is written as a sequence of diagonals and read off as a sequence of rows.

\textit{Cipher machines}: Cryptography was mechanized by the 1900s in the form of encryption machines. The basic component of a cipher machine is the wired rotor.
When we get prior to the Second World War, the Germans realized that, thanks to radios, messages can be sent across the battlefield in an instant but that always meant the other side could also tap into those radio channels. Therefore high-tech encryption was highly needed. The Germans invented Enigma,whose complexity guaranteed their privacy. The Enigma was a substitution cipher, but a more sophisticated one because it used three rotors in a row, each feeding into the next. The Germans typed their messages on a keyboard that came out as gibberish on a lampboard. Then they sent it over the radio to the other side, which also has the same Enigma machine to help them decrypt the unintelligible message. The Germans distributed \textit{cookbooks} with daily settings for the machines. Furthermore, to decrypt the message, it is assumed that the other side must know the algorithm and must have configured the machine the same way as the Enigma machine encrypting the message. The Enigma relies on a random letter generator. Hence, its encryption does not seem to follow any kind of pattern. There are 26 wires coming out of the keyboard, running through three rotors with 6 permutations, going into the lamps representing the output letter. Once the first of the three rotors hits a full evolution, it kicks the next rotor to start moving, yet again, when it completes its cycle, it transmits the process to the last rotor. The inside of the rotors resembles scrambled wiring. A rotor's side has 26 junctions or contacts,  accepting the incoming wires and outputting them to the other side of the rotor. The rotor moves each time a letter is typed in. Even if the same letter is passed sequentially, the rotor would move and a lamp representing a different output letter would light up. Thus, the dynamism of the rotors accounts for the complicated encryption. Finally, a plugboard at the front of the machine allowed letters to be optionally swapped so that the machine it is interacting with is configured the same way. Alan Turing and his colleagues at Bletchley Park were able to break the Enigma codes and automate the process by developing a new machine called \textit{the Bombe} \cite{alanturing}. The rotor machines were cracked because the same key had been used over an extended period of time and due to the use of old compromised keys while encrypting.What is more, the circuitâ€™s configuration showed that it was impossible for a letter to be encrypted as itself, which turned out to be a cryptographic flaw. 

\textbf{Stream ciphers:} A stream cipher generates a stream of bytes, one for each byte of the text we want to encrypt.  An example is Rivest Cipher 4 (RC4), designed in 1987 by Ron Rivest. RC4 uses 64-bit or 128-bit key sizes. Its most popular implementation is in WEP for 802.11 wireless networks and in SSL. RC4 consists of key-scheduling algorithm, which initializes a permutation of all 256 possible bytes \cite{stallings2017}. The permutation itself is started with a length key between 40 and 2048 bits. RC4 is also composed of pseudo-random generation algorithm (PRGA) which generates the stream of bits. PRGA has two 8-bit index pointers (i and j) on which, during the 256 iterations, it executes operations such as XOR-ing, swapping, modulo. Stream ciphers are vulnerable to attacks, mostly to bit-flipping \cite{wikirc4} . Bit-flipping attack deals with changing a bit in a ciphertext so that it results in a predictable plaintext. It is not targeting the cipher itself but a message or a series of messages on a channel. For this reason, it could turn into a Denial of Service attack. We should never reuse a key with a stream cipher. The main reasons being that we can recover the plaintext, using the keystream and the ciphertext. The keystream could be recovered as well using the plaintext and the ciphertext. Furthermore, if we use two ciphertexts from the same keystream, we can recover the XOR-encryption of the plaintexts.

\textbf{Block ciphers:} Block ciphers date back to late 1960s when IBM attempted to develop banking security systems \cite{ibmcrypto}. The result was Lucifer, an encryption method, with 128-bit key and block size, aimed at protecting data for cash-dispensing system in the UK. However, it was not secure in any of its version implementations. 
When we use block ciphers, each block is encrypted independently producing a ciphertext block of equal length. Block ciphers are also called product and have a cipher structure named \emph{Feistel}, as first described by Horst Feistel of IBM in 1973. The Feistel structure consists of a number of identical rounds of processing. In each round,a substitution is performed on one half of the processed data, followed by a permutation that interchanges the two halves. The original key is expanded so that a different key is used for each round. Symmetric block encryption algorithms are based on this structure. 
In general, it is accepted that block ciphers are applicable to a broader range of applications than stream ciphers. 


\textit{DES}

Cryptography gradually moved from hardware to software with the advent of computers. Most famous example of the block cipher design and the classic Feistel structure is the Data Encryption Standard (DES), designed by IBM under the advisement of NASA in 1977, standardized 2 years later. It was meant to encipher sensitive but non classified data. DES complexity is comprised of a simple repetition of the primitives of transposition, substitution, split, concatenation and bit-wise operation.
In DES we put 64-bit block of plaintext,  DES' key (which does the processing) is 64 bit which is 8 bytes but for each byte there is one parity bit, therefore, the value in the key is only 56 bits which means there are 2 to the power of 56 different keys. The output ciphertext is a 64-bit block. 
From the 56-bit key, 16 bits are generated (one for each round). Each DES round works consecutively, has the same operations and uses a different key. Each round uses a combination of proper substitution, where we take some bits which are substituted with another combination of bits. Each DES round takes as an input the ciphertext produced by the previous round and outputs the ciphertext for the next round. The input is divided into a left half and a right half. The output left half is just the right half of the input. The right output is the result of XOR-ing the left half of the input and the output of the Mangler Function (which takes as an input the 32-bit right half, expands it to 48-bit (bit-wise operation) then XORs it to 48-bit key, then uses the S-Boxes to substitute the 48-bit value into a 32-bit value).
The algorithm process of decryption in DES is the same as the encryption process. It uses the ciphertext as an input to DES but the keys are run in reversed order, i.e. k = 16 is used as the first round of decryption, k = 15 is used as a second round of decryption and so on, so forth. 
Diffusion is one of the principles in encryption. It is achieved through permutation (initial transposition). Permutation works by changing the position of the bits in DES. The mixed bits are taken to a sub-box which receives the 56-bit key and the 64-bit plaintext, once it completes processing, it outputs the 64 bits into another transposition subsection, which in turn produces a 64-bit ciphertext. 
The larger the block size, the key size and number of rounds means greater security. However, when there are more than 16 rounds or more than 56 keys, the security will neither be increased nor the encryption will be made any stronger. The possible attacks that often occur on product ciphers are differential cryptanalysis and linear cryptanalysis, however, according to Stallings, DES has proven to be resistant to these sort of attacks \cite{stallings2011-a}. By 1999, a computer could try every possible key in a couple of days rendering the cipher insecure.

\textit{TRIPLE DES/3DES} has replaced DES since the simpler version, relying on the same key for encryption and decryption, is susceptible to brute force attacks. 3DES is a more secure method of symmetric key-encryption, as it encrypts data three times than DES, i.e. the one 56-bit key becomes three individual keys rendering a 168-bit key.However, initiating three instances of DES, implies that 3DES is much slower than other methods of encryption. The text is encrypted firstly with key 1, then with key 2 and key 3 encrypts the last text. Triple DES offers a security level of 2^112 instead of 2Ë†{168} ,i.e. with only two keys of encryption, since the 168-bit key can be cumbersome to implement. This method is known as Encrypt-Decrypt-Encrypt (EDE): key 1 encrypts the message; then the message is decrypted using key 2, afterwards the text is encrypted again with key 2. We should mention that there exists double DES as well, which is composed of two successive instances of DES. 2DES offers a security level of 2Ë†{56} instead of 2Ë†{112} due to the cryptographic attack called \emph{meet-in-the-middle} \cite{mitm}. If we take some plain-texts and encode them and at the same time take some encrypted values and start decrypting them, we only have to look for where they meet in the middle with the same value. Those intersections then reveal the key. 3DES avoids this as we would need to work a third operation to tell if they met in the middle. Thus, it is not enough to look for where the first and last operation produce the same value.

\textit{AES} The Advanced Encryption Standard replaced DES in 2000 as the US Government encryption technique to protect classified information. The symmetric block cipher was developed by two Belgian cryptographers Joan Daemen and Vincent Rijmen. AES was designed to be efficient in both hardware and software. It supports a block length of 128 bits and key lengths of 128, 192, and 256 bits. Thus, brute force attacks, i.e. cryptanalytic attacks attempting all possible key variants to decrypt any enciphered data, are much harder to be launched against it. AES chops data up into 16-byte blocks, transferred to a \emph{State array}, and then applies a series of substitutions (e.g. \emph{Substitute bytes}, \emph{MixColumns}) and permutations (e.g. \emph{ShiftRows}), based on the key value. We note that the State array undergoes various modifications throughout both encryption and decryption. What is more, that way, it obscures the message, by adding diffusion, confusion and non-linearity and repeating the processes ten (for a 16-byte key) or more times (12 rounds for 24-byte key; 14 rounds for a 32-byte key) for each block. In order to \emph{Substitute bytes}, an S-box is used to perform a byte-by-byte substitution of the block. The other substitution called \emph{MixColumns} utilizes arithmetic over GF(2Ë†8) \cite{stallings2017-a}. In fact, all encryption algorithms necessitate arithmetic operations.The key is expanded into an array of key schedule four-byte words. Employing a bitwise XOR of the current block with part of the expanded key is a stage called \emph{AddRoundKey}, solely used on the key. Therefore, the cipher is locked around this stage adding to the security of the AES encryption.  At the end, the State of the plaintext is copied to an output matrix where the bytes are ordered in a column. Similarly, the bytes of the expanded key, which form a word, are placed in the column of the matrix. Today, AES is used everywhere, from encrypting files and sensitive data, transmitting data over WiFi with WPA2, to accessing websites using HTTPS. 

\subsection{Technical}