\section{Background ($\pm$ 15\% total words)}
\subsection{Scientific}

In this section we present Substitution and Transposition ciphers along with Stream and Block ciphers. On the one hand, Substitution ciphers they take the i-th element of a string and change it for another value to produce a ciphertext. Substitution ciphers can be monoalphabetic or polyalphabetic. The former, also called simple substitution cipher, maps a plaintext letter to a ciphertext letter based on a single alphabet key. The latter uses multiple substitution alphabets. In Transposition ciphers the values of plain letters are not changed for another but preserved and rearranged. Modern ciphers use a combination of both substitution and transposition ciphers. On the other hand, Stream ciphers convert one symbol (1 bit or byte) of plaintext directly into a symbol of ciphertext. Block ciphers encrypt a group of plaintext symbols as one block and outputs a block of ciphertext. We add that Substitution ciphers can operate on either blocks or streams. 

\textbf{Substitution ciphers:} 
The most popular secure example of substitution cipher is the One - Time Pad (OTP), designed in 1917. It is employed by Russian spies, the CIA covert operations and the \emph{hotline} Washington-Moscow. A pad (secret key) is never reused. Instead, it utilizes a random key which has an equal length to the message. The random key is also used in encryption and decryption of the message, and afterwards is discarded \cite{stallings2011}. If we want to generate a new message, a new key is required. Thus, this scheme leads to an output unrelated to the plaintext. If we try to decipher a ciphertext using this method, and let us suppose we have succeeded in finding the key, our attempts would lead us to fairly different decrypted outputs. For this reason, it would be difficult to decide upon the correct decryption. Stallings claims there are two fundamental complexities related to the one-time pad: (1) making large quantities of random keys; (2) key distribution and protection (since a key of equal length is needed by both sender and receiver). Hence, if we ought to employ the one-time pad, it would be best for  for low-bandwidth channels requiring very high security \cite{stallings2011}. Nevertheless, this cryptosystem is regarded as the sole exhibiting perfect secrecy \cite{stallings2011}. Cipher machines, presented below in this report, attempted unsuccessfully, first mechanically, then electronically, to create approximations to one-time pads (OTPs). Many snake oil algorithms claim inability to break by claiming to be OTPs, hence, giving a rise to pseudo-OTPs providing pseudo-security \cite{curtin1998}.

In order to produce the ciphertext, a substitution cipher modifies characters in the plaintext. We can break the monoalphabetic cipher by using letter frequency analysis since letter frequencies are preserved (e.g. e is the most common letter in English, followed by t,i,o,a,n,s,r ). The polyalphabetic cipher can be broken by decomposing into individual alphabets and as a consequence to treat is as a simple substitution cipher. A historical example of breaking the substitution cipher is the execution of the Queen of Scots, Mary, in 1587 for plotting to kill Queen Elizabeth \cite{maryscots}. The "Vigenere Cipher" is the most popular polyalphabetic cipher.The Vigenere Cipher is an improvement of the Caesar Cipher but not as secure as the unbreakable One Time Pad. Recall that the Caesar Cipher encodes each plain letter by a constant shift whereas the One Time Pad shifts each plain letter depending on the corresponding keyword letter. Now, the Vigenere Cipher uses a keyword of given length repeatedly to determine the encoding shift of each plain letter. For instance, we are given a word, we convert to numbers, according to the letter position in the alphabet. Next, we repeat the sequence of numbers along the message. Then, we encrypt each letter in the message by shifting according to the number below it and send the encrypted message openly to the recipient. Hence, we employ multiple shifts. To decrypt the message, we must subtract the shifts according to the secret word or key we have a copy of.

\textbf{Transposition ciphers:} Another kind of mapping is achieved by performing permutation on the plaintext letters. This technique is referred to as a transposition cipher. For example, a simple cipher of this sort is the rail fence technique. The plaintext is written as a sequence of diagonals and read off as a sequence of rows.The key is the number of rows used to encode. 

With today's computer power transposition ciphers can be broken quickly. Trying to compute the frequencies of the cipher letters is one method. Another way is testing possible rearrangements. For instance, one may try to read the cipher text backwards. If that does not yield the plain text then the rail fence technique could be tested. If that does not yield the plain text, one could check if two consecutive letters were switched.    

\textit{Cipher machines}: Cryptography was mechanized by the 1900s in the form of encryption machines. The basic component of a cipher machine is the wired rotor.
When we get prior to the Second World War, the Germans realized that, thanks to radios, messages can be sent across the battlefield in an instant but that always meant the other side could also tap into those radio channels. Therefore high-tech encryption was highly needed. The Germans invented Enigma,whose complexity guaranteed their privacy. The Enigma was a substitution cipher, but a more sophisticated one because it used three rotors in a row, each feeding into the next. The Germans typed their messages on a keyboard that came out as gibberish on a lampboard. Then they sent it over the radio to the other side, which also has the same Enigma machine to help them decrypt the unintelligible message. The Germans distributed \textit{cookbooks} with daily settings for the machines. Furthermore, to decrypt the message, it is assumed that the other side must know the algorithm and must have configured the machine the same way as the Enigma machine encrypting the message. The Enigma relies on a random letter generator. Hence, its encryption does not seem to follow any kind of pattern. There are 26 wires coming out of the keyboard, running through three rotors with 6 permutations, going into the lamps representing the output letter. Once the first of the three rotors hits a full evolution, it kicks the next rotor to start moving, yet again, when it completes its cycle, it transmits the process to the last rotor. The inside of the rotors resembles scrambled wiring. A rotor's side has 26 junctions or contacts,  accepting the incoming wires and outputting them to the other side of the rotor. The rotor moves each time a letter is typed in. Even if the same letter is passed sequentially, the rotor would move and a lamp representing a different output letter would light up. Thus, the dynamism of the rotors accounts for the complicated encryption. Finally, a plugboard at the front of the machine allowed letters to be optionally swapped so that the machine it is interacting with is configured the same way. Alan Turing and his colleagues at Bletchley Park were able to break the Enigma codes and automate the process by developing a new machine called \textit{the Bombe} \cite{alanturing}. The rotor machines were cracked because the same key had been used over an extended period of time and due to the use of old compromised keys while encrypting.What is more, the circuitâ€™s configuration showed that it was impossible for a letter to be encrypted as itself, which turned out to be a cryptographic flaw. 

\textbf{Stream ciphers:} A stream cipher generates a stream of bytes, one for each byte of the text we want to encrypt.  An example is Rivest Cipher 4 (RC4), designed in 1987 by Ron Rivest. RC4 uses either 64-bit or 128-bit key sizes. Its most popular implementation is in WEP for 802.11 wireless networks and in SSL. RC4 consists of a key-scheduling algorithm, which initializes a permutation of all 256 possible bytes \cite{stallings2017}. The permutation itself is started with a length key between 40 and 2048 bits. RC4 is also composed of pseudo-random generation algorithm (PRGA) which generates the stream of bits. PRGA has two 8-bit index pointers (i and j) on which, during the 256 iterations, it executes operations such as XOR-ing, swapping, modulo. Stream ciphers are vulnerable to attacks, mostly to bit-flipping \cite{wikirc4} . Bit-flipping attack deals with changing a bit in a ciphertext so that it results in a predictable plaintext. It is not targeting the cipher itself but a message or a series of messages on a channel. For this reason, it could turn into a Denial of Service attack. We should never reuse a key with a stream cipher. The main reasons being that we can recover the plaintext, using the keystream and the ciphertext. The keystream could be recovered as well using the plaintext and the ciphertext. Furthermore, if we use two ciphertexts from the same keystream, we can recover the XOR-encryption of the plaintexts.

\textbf{Block ciphers:} Block ciphers date back to late 1960s when IBM attempted to develop banking security systems \cite{ibmcrypto}. The result was Lucifer, an encryption method, with 128-bit key and block size, aimed at protecting data for cash-dispensing system in the UK. However, it was not secure in any of its version implementations. 
When we use block ciphers, each block is encrypted independently producing a ciphertext block of equal size. The block size can be 64-bits, 128-bits or 256-bits. The ciphertext is generated from the plaintext and the key by iterating a \emph{round function} (as we go through it several times). Input to the round functions consists of key and the output of previous round. Block ciphers are also known as \emph{product} ciphers and are built with a \emph{Feistel structure}, as first described by Horst Feistel of IBM in 1973. The plaintext is split into left and right halves. The Feistel design consists of a number of identical rounds of processing. During each round, substitution is performed on one half of the processed data, followed by a permutation that interchanges the two halves. What is more, the original key is expanded so that a different key is used for each round. Symmetric block encryption algorithms are based on this structure. In general, it is accepted that block ciphers are applicable to a broader range of applications in software as opposed to stream ciphers.

When we want to encrypt longer than a 16-byte plaintext (email, file, etc.) with a symmetric key block cipher algorithm, there exist several modes of operation:
\begin{itemize}
\item ECB (Electronic Code Book mode)
\end{itemize}
\begin{itemize}
\item CBC (Cipher Block Chaining mode)
\end{itemize}
\begin{itemize}
\item CFB (Cipher Feedback mode) 
\end{itemize}
\begin{itemize}
\item OFB (Output Feedback mode)
\end{itemize}
\begin{itemize}
\item CTR (Counter mode)
\end{itemize}
These modes aim at providing confidentiality and protection for sensitive data. The latter three modes use the block cipher as a building block for a stream cipher \cite{springer2010}. To encrypt data with DES and AES our project utilizes ECB and CBC modes, respectively. ECB requires that the length of the plaintext is a multiple of the block size of the cipher used. If the plaintext does not conform to the required length, it must be padded. Padding is achieved by appending as many zero bits as possible in order to reach a multiple of the block length (i.e. 8, 16, 32, etc.). In case the plaintext conforms to the length, an extra block is appended consisting of only padding bits. Furthermore, in ECB mode each block is encrypted separately. One of the advantages of ECB is that if a transmission problem occurs, the received encrypted block could still be decrypted \cite{springer2010}. Moreover, parallelization is allowed in ECB mode, i.e. one encryption unit encrypts block 1, the next one block 2, etc., which is useful in high-speed implementations \cite{springer2010}. Nevertheless, there are some weaknesses associated with the ECB mode. During encryption identical plaintext blocks result in identical ciphertext blocks as long as the key does not change \cite{springer2010}. Hence, an attacker could easily deduce information. The ECB mode is susceptible to substitution attacks because once block mapping from plaintext to ciphertext is known, a sequence of ciphertexts can be manipulated \cite{springer2010}. 
With regard to CBC, all encrypted blocks are chained together such that a certain ciphertext depends not only on a certain block but on all previous plaintext blocks as well \cite{morris2001}. Each plaintext block also gets XORed with the previous ciphertext block prior to encryption \cite{morris2001}. In addition, the encryption is randomized by using an initialization vector (IV). In our case, the IV is new every time we encrypt and is always incremented when a new session starts. If we encrypt a string once with a first IV and a second time with a different IV, the two resulting ciphertext sequences look completely unrelated to each other. To strengthen the encryption method, a mode of operation is used, for AES we have chosen CBC mode. 

\textit{DES}: Cryptography gradually moved from hardware to software with the advent of computers. Most famous example of the block cipher design and the classic Feistel structure is the Data Encryption Standard (DES), designed by IBM under the advisement of NASA in 1977, standardized 2 years later. It was meant to encipher sensitive but non classified data. DES complexity is comprised of a simple repetition of the primitives of transposition, substitution, split, concatenation and bit-wise operation. DES uses a 56-bit key. The cipher is thoroughly examined in point 4 of this report for it has been used in our hands-on approach.

\textit{TRIPLE DES/3DES} has replaced DES since the simpler version, relying on the same key for encryption and decryption, is susceptible to brute force attacks. 3DES is a more secure method of symmetric key-encryption, as it encrypts data three times than DES, i.e. the one 56-bit key becomes three individual keys rendering a 168-bit key.However, initiating three instances of DES, implies that 3DES is much slower than other methods of encryption. The text is encrypted firstly with key 1, then with key 2 and key 3 encrypts the last text. Triple DES offers a security level of $2^{112}$ instead of $2^{168}$,i.e. with only two keys of encryption, since the 168-bit key can be cumbersome to implement. This method is known as Encrypt-Decrypt-Encrypt (EDE): key 1 encrypts the message; then the message is decrypted using key 2, afterwards the text is encrypted again with key 2. We should mention that there exists double DES as well, which is composed of two successive instances of DES. 2DES offers a security level of $2^{56}$ instead of $2^{112}$ due to the cryptographic attack called \emph{meet-in-the-middle} \cite{mitm}. If we take some plain-texts and encode them and at the same time take some encrypted values and start decrypting them, we only have to look for where they meet in the middle with the same value. Those intersections then reveal the key. 3DES avoids this as we would need to work a third operation to tell if they met in the middle. Thus, it is not enough to look for where the first and last operation produce the same value.

\textit{AES} The Advanced Encryption Standard replaced DES in 2000 as the US Government encryption technique to protect classified information. The symmetric block cipher was developed by two Belgian cryptographers Joan Daemen and Vincent Rijmen. AES was designed to be efficient in both hardware and software. It supports a block length of 128 bits and key lengths of 128, 192, and 256 bits. Thus, brute force attacks, i.e. cryptanalytic attacks attempting all possible key variants to decrypt any enciphered data, are much harder to be launched against it. AES chops data up into 16-byte blocks, transferred to a \emph{State array}, and then applies a series of substitutions (e.g. \emph{Substitute bytes}, \emph{MixColumns}) and permutations (e.g. \emph{ShiftRows}), based on the key value. We note that the State array undergoes various modifications throughout both encryption and decryption. What is more, that way, it obscures the message, by adding diffusion, confusion and non-linearity and repeating the processes ten (for a 16-byte key) or more times (12 rounds for 24-byte key; 14 rounds for a 32-byte key) for each block. In order to \emph{Substitute bytes}, an S-box is used to perform a byte-by-byte substitution of the block. The other substitution called \emph{MixColumns} utilizes arithmetic over GF($2^{8}$) \cite{stallings2017-a}. In fact, all encryption algorithms necessitate arithmetic operations.The key is expanded into an array of key schedule four-byte words. Employing a bitwise XOR of the current block with part of the expanded key is a stage called \emph{AddRoundKey}, solely used on the key. Therefore, the cipher is locked around this stage adding to the security of the AES encryption.  At the end, the State of the plaintext is copied to an output matrix where the bytes are ordered in a column. Similarly, the bytes of the expanded key, which form a word, are placed in the column of the matrix. Today, AES is used everywhere, from encrypting files and sensitive data, transmitting data over WiFi with WPA2, to accessing websites using HTTPS. 

\subsection{Technical}

One of the deliverables of this project is a Python chat system. The application encrypts messages and employs ciphers reviewed in this report. Python is a programming language created by Guido van Rossum in late 1980s in the Netherlands. It is named after a BBC comedy show called \emph{Monty Python's Flying Circus}. Python is a free software and the latest version can be downloaded from \url{www.python.org}. Python is a simple and very powerful general purpose computer programming language. It is very readable, useful and easy to learn. Python is an open source language with volunteers constantly trying to improve it. This allows for the language to remain fresh and current with the newest trends. Python has libraries for just about everything. It can be used for web development, web scraping, writing scripts, browser automation, GUI development, data analysis, machine learning, computer vision and game development, to list just a few. In addition, Python is an object-oriented programming language (OOP). There are four pillars of OOP: encapsulation, abstraction, inheritance and polymorphism. Before turning to OOP, there is procedural programming, a simple and straightforward programming, that divides a program into a set of functions. However, as our programs grow we end up with \emph{spaghetti code}, i.e. many functions all over the place that are interdependent. Thus, OOP offers a solution to this issue. We can bundle a group of related variables (referred to as \emph{properties}) and functions that operate on them (referred to as \emph{methods}) into an object. This grouping is called \emph{encapsulation}. Using this technique, we can reduce complexity and increase reusability. In Python, objects are data and have a certain type (integer, float, list, etc.). Once we have created our objects we can manipulate and interact with them (append, sort, delete, concatenate, etc.). We can hide the details and complexity (e.g. some methods and properties) from the outside and show only the essentials through the process of \emph{abstraction}. This is beneficial as we produce simpler interface and reduce the impact of change (i.e. no inner changes leak to the outside of the contained object). \emph{Inheritance} is a mechanism that allows us to eliminate redundant code. \emph{Polymorphism} is a technique that allows us to refactor long if/ else or switch/case statements. 

Our platform is macOS and we can open Python on a Terminal. Moreover, we can use any Text Editor or IDLE of our choice. For this project, we have used the source code editor Visual Studio Code (VSC) developed by Microsoft. VSC is a lightweight yet powerful editor. It offers support for debugging, embedded Git control, syntax highlighting, snippets, extensions, smart code completion and code refactoring. 

A GitHub repository was set up to share and build our project. The link is provided in the annex of the report. GitHub is a web-based hosting service of open source projects for version control using Git. 

To build the chat program for our project we need a client and a server. To establish a connection between both and be able to transmit information back and forth over the Internet, we need a socket link. Sockets aid the communication between these two entities. The client requests information from the server and the server carries out data to the client. The server is just a software, a program running and waiting for connections. Similarly, the client is a program as well. However, altogether, they are referred to as \emph{client/server architecture}. For instance, when we visit a website, we are using a socket and accessing a port of the web server. In this case, the server has generally port 80 open, used to transfer HTTP data. Other websites have ports 21 and 20 open for FTP access, which is not very secure, some have port 22 intended for SSH. The lower number ports are specific ports, whereas the higher number ports signify general purpose rights. More often than not, questions arise regarding security when using higher number ports. To use sockets, we need to import them by typing in import socket. We do not need to install anything as they are part of our standard library. Next we need to specify and create a socket by: s = socket.socket(socket.AF\_INET, socket.SOCK\_STREAM) where AF\_NET signals the connection type we want to use and SOCK\_STREAM allows us to make a TCP connection. 

Our client should send an initial request to the server's port number, \emph{the listening port}. To keep the communication over TCP, we have the client's IP address and local port number as well as the server's IP address along with its port number. Each client that connects to the server gets unique set of values of two IP addresses and two port numbers in a tuple, a collection of items. However, the listening port of the server remains intact. 